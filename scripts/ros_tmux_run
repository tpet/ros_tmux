#!/bin/bash
set -e

ros_arg() {
    for arg in "${@:2}"; do
        if [[ $arg == "$1:="* ]]; then
            start=`expr \${#1} + 2`
            echo "${arg:${start}}"
        fi
    done
}

log() {
    echo -e [ros_tmux] `date "$date_fmt"`: "$@" >> "$log" 2>&1
#    echo -e [ros_tmux] `date "$date_fmt"`: "$@" >> "$ROS_LOG_FILENAME" 2>&1
}

run_id() {
    rosparam get /run_id
}

date_fmt='+%Y-%m-%d %H:%M:%S.%3N'
node="`ros_arg __name \"$@\"`"
#ns="`ros_arg __ns \"$@\"`"
#ns="${ROS_NAMESPACE}"
#ROS_NAMESPACE="`ros_arg __ns \"$@\"`"
log="`ros_arg __log \"$@\"`"
#ROS_LOG_FILENAME="`ros_arg __log \"$@\"`"
ROS_LOG_FILENAME="$log"
if [[ "${ros_tmux_session}" = "run_id" ]]; then
    run_id=`run_id`
    sess=ros_tmux_${run_id}
else
    sess=ros_tmux
fi
#ns_prefix=`echo "${ns:1}/" | tr '/' '-'`
if [[ ! -z "${ROS_NAMESPACE}" ]]; then
    ns_prefix=`echo "${ROS_NAMESPACE:1}/" | tr '/' '-'`
else
    ns_prefix=
fi
win="${ns_prefix}${node}"
# Create a unique tmux channel for this run, not to get confused by signals from other runs.
channel="$(uuidgen)"

log Command: "$0" "$@"
if [[ "$run_id" ]]; then
    log "Run ID: ${run_id}"
fi
log "Node: $1 [$node]"
log "Log: $log"
#log "Log: $ROS_LOG_FILENAME"
log "Session: $sess"
log "Window: $win"
log "Channel: $channel"
log "ROS env:\n`env | grep ROS`"

# Source tmux config before starting new window (indexing from 1).
# Avoid server stopping immediately due to no running session.
# https://github.com/tmux/tmux/issues/736
# Create session and window as needed, avoid printouts.
log "Setting up session, configuration, and window (if needed)..."
ros_tmux="`rospack find ros_tmux`"
conf=$ros_tmux/config/ros_tmux.conf
tmux start-server \; source "$conf" \; new-session -d -s $sess -n $win >/dev/null 2>/dev/null \
    || tmux start-server \; source "$conf" \; list-windows -t $sess | grep $win >/dev/null 2>/dev/null \
    || tmux start-server \; source "$conf" \; new-window -d -n $win >/dev/null 2>/dev/null

# Terminate whatever is running there before running the program.
log "Terminating previous node if any."
tmux send-keys -t $sess:$win C-c C-m
#sleep 0.001

# Forward env variables to the node (i.e., tmux window).
for var in ROS_HOSTNAME ROS_IP ROS_LOG_FILENAME ROS_MASTER_URI ROS_NAMESPACE; do
    if [[ -z "${!var+x}" ]]; then
        continue
    fi
    cmd="export ${var}=\"${!var}\""
    log "Sending keys: $cmd"
    tmux send-keys -t $sess:$win -l '' "$cmd"
    tmux send-keys -t $sess:$win C-m
done

# Avoiding striping spaces between arguments but use parameter expansion.
# tmux send-keys -l -t $sess:$win '' \'"${@:3}"\'
cmd="ros_tmux_node ${channel} $@"
log "Sending keys: $cmd"
tmux send-keys -t $sess:$win -l '' "$cmd"
tmux send-keys -t $sess:$win C-m
log "Node started [$channel]."

log_finish() {
    log "Node finished [$channel].\n"
}
trap log_finish EXIT

sigint_node() {
    log "Forwarding SIGINT signal to node."
    tmux send-keys -t $sess:$win C-c
    # https://stackoverflow.com/questions/7771557/how-to-terminate-a-window-in-tmux
    # tmux kill-window -t $sess:$win
}
sigquit_node() {
    log "Forwarding SIGQUIT signal to node."
    tmux send-keys -t $sess:$win C-\\
}
trap sigint_node SIGINT
trap sigquit_node SIGQUIT SIGTERM

# https://unix.stackexchange.com/questions/144663/have-tmux-wait-until-i-ssh-in-to-complete-rest-of-tmuxinator-script
# Handlers don't get called before tmux wait-for returns which prevents clean shutdown via Ctrl-C.
# tmux wait-for "${runid}"
tmux wait-for "${channel}" &
until wait; do
    true
done
